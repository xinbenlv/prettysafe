<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Create2Crunch WebGPU Benchmark</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background: #111; color: #eee; }
        h1 { color: #fff; }
        button { background: #007bff; border: none; color: white; padding: 10px 20px; font-size: 16px; cursor: pointer; border-radius: 4px; margin-right: 10px; }
        button:hover { background: #0056b3; }
        button:disabled { background: #444; cursor: not-allowed; }
        pre { background: #222; padding: 15px; border-radius: 4px; overflow-x: auto; color: #0f0; min-height: 200px; }
        .status { margin-bottom: 20px; padding: 10px; border-radius: 4px; }
        .success { background: #155724; color: #d4edda; }
        .error { background: #721c24; color: #f8d7da; }
        .info { background: #0c5460; color: #d1ecf1; }
    </style>
</head>
<body>
    <h1>Create2Crunch WebGPU Benchmark</h1>

    <div id="status" class="status info">Checking WebGPU support...</div>

    <div id="controls">
        <button id="btnRun" disabled>Run Benchmark (5s)</button>
    </div>

    <h3>Output</h3>
    <pre id="output">Waiting for start...</pre>

    <script type="module">
        const output = document.getElementById('output');
        const status = document.getElementById('status');
        const btnRun = document.getElementById('btnRun');

        function log(msg) {
            output.textContent += msg + '\n';
            output.scrollTop = output.scrollHeight;
        }

        async function init() {
            if (!navigator.gpu) {
                status.className = 'status error';
                status.textContent = '❌ WebGPU is not supported in this browser. Please use Chrome/Edge/Firefox with WebGPU enabled.';
                return;
            }

            try {
                const adapter = await navigator.gpu.requestAdapter({ powerPreference: "high-performance" });
                if (!adapter) {
                    status.className = 'status error';
                    status.textContent = '❌ Failed to request GPU adapter.';
                    return;
                }

                const info = await adapter.requestAdapterInfo();
                status.className = 'status success';
                status.textContent = `✅ WebGPU Ready: ${info.vendor} ${info.architecture}`;
                btnRun.disabled = false;

                btnRun.onclick = () => runBenchmark(adapter);
            } catch (e) {
                status.className = 'status error';
                status.textContent = `❌ Error: ${e.message}`;
            }
        }

        async function runBenchmark(adapter) {
            btnRun.disabled = true;
            output.textContent = '';
            log("Initializing...");

            try {
                const device = await adapter.requestDevice();

                // Fetch shader
                const shaderResponse = await fetch('/keccak.wgsl');
                const shaderCode = await shaderResponse.text();
                const shaderModule = device.createShaderModule({ code: shaderCode });

                // Prepare buffers
                const templateState = new Uint32Array(50);
                for (let i = 0; i < 50; i++) templateState[i] = Math.floor(Math.random() * 0xFFFFFFFF);

                const templateBuffer = device.createBuffer({
                    size: templateState.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });
                device.queue.writeBuffer(templateBuffer, 0, templateState);

                const paramsBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
                const solutionsBuffer = device.createBuffer({ size: 8, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST });

                const bindGroupLayout = device.createBindGroupLayout({
                    entries: [
                        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
                        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },
                    ],
                });

                const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
                const pipeline = device.createComputePipeline({
                    layout: pipelineLayout,
                    compute: { module: shaderModule, entryPoint: "main" },
                });

                const bindGroup = device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [
                        { binding: 0, resource: { buffer: templateBuffer } },
                        { binding: 1, resource: { buffer: paramsBuffer } },
                        { binding: 2, resource: { buffer: solutionsBuffer } },
                    ],
                });

                const workgroupSize = 256;
                const dispatchCount = 65535;
                const totalItemsPerDispatch = workgroupSize * dispatchCount;

                log(`Workgroup Size: ${workgroupSize}`);
                log(`Dispatch Count: ${dispatchCount}`);
                log(`Items per Dispatch: ${totalItemsPerDispatch.toLocaleString()}`);

                let totalHashes = 0;
                const startTime = performance.now();
                let lastLog = startTime;
                let nonceHigh = 0;
                const durationTarget = 5000; // 5s

                log("Running...");

                while (true) {
                    const params = new Uint32Array([nonceHigh++, 0, 0, 0]);
                    device.queue.writeBuffer(paramsBuffer, 0, params);

                    const commandEncoder = device.createCommandEncoder();
                    const passEncoder = commandEncoder.beginComputePass();
                    passEncoder.setPipeline(pipeline);
                    passEncoder.setBindGroup(0, bindGroup);
                    passEncoder.dispatchWorkgroups(dispatchCount);
                    passEncoder.end();

                    device.queue.submit([commandEncoder.finish()]);
                    await device.queue.onSubmittedWorkDone();

                    totalHashes += totalItemsPerDispatch;

                    const now = performance.now();
                    const elapsed = now - startTime;

                    if (elapsed >= durationTarget) break;

                    if (now - lastLog > 1000) {
                        const rate = totalHashes / (elapsed / 1000);
                        log(`Running... ${(rate / 1_000_000).toFixed(2)} MH/s`);
                        lastLog = now;
                    }
                }

                const endTime = performance.now();
                const durationSec = (endTime - startTime) / 1000;
                const hashrate = totalHashes / durationSec;

                log("-------------------------");
                log(`Benchmark Complete!`);
                log(`Total Hashes: ${totalHashes.toLocaleString()}`);
                log(`Duration: ${durationSec.toFixed(4)}s`);
                log(`Hashrate: ${(hashrate / 1_000_000).toFixed(2)} MH/s`);

            } catch (e) {
                log(`Error: ${e.message}`);
                console.error(e);
            } finally {
                btnRun.disabled = false;
            }
        }

        init();
    </script>
</body>
</html>

